1. Identity and Source Model

1.1 Canonical identity fields

Each document has:
	•	id (UUID): internal surrogate key generated by Catalog.
	•	external_id (string): natural key in the source system.
	•	source_type (enum string): high-level category such as imessage, sms, email, note, reminder, calendar_event, file.
	•	source_provider (enum string): implementation/provider such as apple_messages, local_imap, gmail_api, filesystem, hostagent_file_watcher.
	•	source_account_id (string, nullable): stable account identifier when the source can have multiple instances (e.g., multiple email accounts).

external_id must be unique within (source_type, source_provider, source_account_id).

Takeaway: every document is uniquely identified by the tuple (source_type, source_provider, source_account_id, external_id) and has a surrogate id for internal joins.

⸻

2. Document Core Schema

2.1 Required top-level fields

Core documents table / model:
	•	id (UUID).
	•	external_id (string).
	•	source_type (string enum).
	•	source_provider (string enum).
	•	source_account_id (string, nullable).
	•	text (text): fully extracted and normalized text content.
	•	text_sha256 (string): hash of text for dedupe.
	•	content_timestamp (timestamp with time zone): primary time anchor.
	•	content_timestamp_type (enum string): describes what content_timestamp means, values such as sent, received, event_start, due, created, modified.
	•	metadata (JSONB): structured metadata per spec in section 4.
	•	people (JSONB): normalized structured people associated with the document (collector-provided, with roles like sender, recipient, participant).

Takeaway: the document row contains the full text, a single canonical timestamp, identity fields, and structured metadata and people.

⸻

3. Timestamps

3.1 Canonical rules

There is one canonical “primary” timestamp per document:
	•	content_timestamp is the definitive time anchor for sorting and time-based analysis.
	•	content_timestamp_type describes its semantics.

metadata.timestamps mirrors this and holds source-specific clocks.

No created_at/modified_at fields are stored at the document level.

Takeaway: all timing semantics flow from content_timestamp and structured metadata.

3.2 metadata.timestamps structure

metadata.timestamps has this structure:

"timestamps": {
  "primary": {
    "value": "<ISO-8601 UTC timestamp>",
    "type": "<enum string matching content_timestamp_type>"
  },
  "source_specific": {
    "<source_field_name>": "<ISO-8601 or raw string>",
    "...": "..."
  }
}

Rules:
	•	primary.value must equal content_timestamp.
	•	primary.type must equal content_timestamp_type.
	•	source_specific keys are source-defined (e.g., sent_at, received_at, internaldate, header_date, fs_created, fs_modified, exif_taken_at).

Takeaway: consumers can rely on primary for canonical behavior and inspect source_specific only when needed.

3.3 Collector-specific rules

These rules apply to how collectors set content_timestamp and content_timestamp_type.

iMessage / SMS
	•	If message is sent by the local user:
	•	content_timestamp = sent_at.
	•	content_timestamp_type = "sent".
	•	If message is received:
	•	content_timestamp = received_at if available, else sent_at.
	•	content_timestamp_type = "received".
	•	metadata.timestamps.source_specific includes:
	•	sent_at
	•	received_at (if present)

Email
	•	Prefer header Date as primary:
	•	If header Date can be parsed:
	•	content_timestamp = parsed header Date in UTC.
	•	content_timestamp_type = "sent".
	•	Else:
	•	content_timestamp = IMAP internaldate (UTC).
	•	content_timestamp_type = "received".
	•	metadata.timestamps.source_specific includes:
	•	header_date (raw header string).
	•	internaldate (ISO-8601 UTC).
	•	Any other time fields you choose to surface.

Files / standalone documents
	•	If EXIF taken_at exists and the document is modeled as a photo:
	•	content_timestamp = EXIF taken_at in UTC.
	•	content_timestamp_type = "created".
	•	Otherwise:
	•	content_timestamp = filesystem modified time or created time depending on the agreed rule (pick one and document; assume fs_modified here).
	•	content_timestamp_type = "modified".
	•	metadata.timestamps.source_specific includes:
	•	fs_created.
	•	fs_modified.
	•	exif_taken_at where applicable.

Notes, reminders, calendar events
	•	Notes:
	•	content_timestamp = last modified or created, whichever you choose to be canonical (prefer modified).
	•	content_timestamp_type = "modified" or "created" accordingly.
	•	Reminders:
	•	If due date exists:
	•	content_timestamp = due date.
	•	content_timestamp_type = "due".
	•	Else:
	•	content_timestamp = created or last modified.
	•	content_timestamp_type = "created" or "modified".
	•	Calendar events:
	•	content_timestamp = event start datetime.
	•	content_timestamp_type = "event_start".

Takeaway: each collector has a deterministic rule for selecting the primary timestamp, with all raw clocks preserved in source_specific.

⸻

4. Metadata Structure

4.1 Top-level metadata keys

metadata has a fixed set of top-level keys:

"metadata": {
  "ingested_at": "<ISO-8601 UTC timestamp>",

  "timestamps": { ... },

  "attachments": [ ... ],

  "source": { ... },

  "type": { ... },

  "enrichment": { ... },

  "extraction": { ... }
}

	•	ingested_at: when Catalog stored this document.
	•	timestamps: as defined in section 3.2.
	•	attachments: full description of any attached images/files.
	•	source: raw source-system oriented details.
	•	type: normalized, type-specific semantics.
	•	enrichment: ML-derived enrichment over the document text.
	•	extraction: ingestion and parsing diagnostics.

Takeaway: metadata is partitioned into well-defined namespaces so that data is not mixed arbitrarily.

4.2 metadata.attachments

Attachments represent any file/image that is part of the document (inline images, email attachments, the original file for a file-backed document).

Schema:

"attachments": [
  {
    "index": 0,
    "kind": "image",          // e.g. image | pdf | file | other
    "role": "attachment",     // e.g. attachment | inline | thumbnail | related
    "mime_type": "image/jpeg",
    "size_bytes": 359915,

    "source_ref": {
      "path": "/Users/you/Downloads/IMG_1234.JPG",
      "message_attachment_id": 42,
      "page": 1               // for page-based artifacts (optional)
    },

    "ocr": {
      "text": "Extracted text...",
      "confidence": 0.96,
      "language": "en",
      "regions": [
        {
          "text": "Acme Corp",
          "bounding_box": { "x": 0.1, "y": 0.2, "width": 0.3, "height": 0.05 },
          "confidence": 0.97,
          "detected_language": "en"
        }
      ]
    },

    "caption": {
      "text": "Invoice from Acme Corp",
      "model": "hostagent-caption-v1",
      "confidence": 0.85,
      "generated_at": "2025-01-10T12:35:10Z"
    },

    "vision": {
      "faces": [
        {
          "bounding_box": { "x": 0.3, "y": 0.2, "width": 0.15, "height": 0.2 },
          "confidence": 0.92,
          "quality_score": 0.85
        }
      ],
      "objects": [
        { "label": "person", "confidence": 0.95, "count": 1 }
      ],
      "scene": "indoor"
    },

    "exif": {
      "camera": "iPhone 14 Pro",
      "taken_at": "2023-03-27T23:45:00Z",
      "location": { "latitude": 37.7749, "longitude": -122.4194 },
      "width": 1920,
      "height": 1080
    }
  }
]

All OCR, caption, face, and EXIF information lives here.

Takeaway: there is no separate files table; all file-level enrichment is embedded in metadata.attachments.

4.3 metadata.source

metadata.source contains raw source-system details.

Examples (not exhaustive):
	•	iMessage:

"source": {
  "imessage": {
    "chat_guid": "iMessage;-;+15551234567",
    "handle_id": 42,
    "service": "iMessage",
    "row_id": 123456
  }
}


	•	Email:

"source": {
  "email": {
    "folder": "INBOX",
    "uid": 12345,
    "raw_flags": ["\\Seen", "\\Answered"],
    "header_map": { "Message-ID": "<abc@example.com>", "...": "..." }
  }
}



Takeaway: source is for low-level source data that might be useful for debugging or advanced features but is not required for the core semantics.

4.4 metadata.type

metadata.type exposes normalized semantics by document kind.

Base:

"type": {
  "kind": "email"  // or imessage | sms | note | reminder | calendar_event | file | ...
}

Examples:
	•	For kind = "email":

"type": {
  "kind": "email",
  "email": {
    "subject": "Invoice for AC service",
    "is_outbound": true,
    "in_reply_to_message_id": "<abc123@example.com>",
    "thread_hint": "<root-message-id-if-used>"
  }
}


	•	For kind = "imessage":

"type": {
  "kind": "imessage",
  "imessage": {
    "direction": "outgoing",   // or incoming
    "is_group": true
  }
}


	•	For kind = "reminder":

"type": {
  "kind": "reminder",
  "reminder": {
    "status": "open",        // open | completed
    "priority": 1,           // domain-specific scale
    "due_date": "2025-02-01T09:00:00Z"
  }
}



Takeaway: consumers can use type.kind to branch logic and then read a stable type-specific schema.

4.5 metadata.enrichment

metadata.enrichment is for ML-derived document-level signals over text (including attachment text where you choose to fold it in).

Example:

"enrichment": {
  "entities": [
    { "text": "Acme HVAC", "type": "organization", "offset": 10, "length": 9 },
    { "text": "Tuesday", "type": "date", "offset": 85, "length": 7 }
  ],
  "classification": {
    "categories": [
      { "label": "home_maintenance", "confidence": 0.92 }
    ]
  }
}

Takeaway: enrichment captures what ML thinks about the document as a whole.

4.6 metadata.extraction

metadata.extraction tracks how the document was ingested and processed.

Example:

"extraction": {
  "collector_name": "imessage",
  "collector_version": "1.3.0",
  "hostagent_modules": ["ocr", "entities", "faces"],
  "warnings": [
    { "code": "ATTACHMENT_OCR_FAILED", "attachment_index": 2 }
  ]
}

Takeaway: extraction is diagnostic; it supports debugging, observability, and upgrade decisions.

⸻

5. Threads

5.1 Purpose and scope

A thread represents a conversation between 2..n people.

Threads are only modeled for imessage / sms.

Threads:
	•	Provide richer context for retrieval and analysis (intent, social graph, context windows).
	•	Match the user mental model of a “conversation” or “chat”.

Takeaway: threads are first-class objects but limited in scope to message-like sources (currently iMessage/SMS).

5.2 Thread identity and relationship

Thread schema (conceptual):
	•	id (UUID): internal thread id.
	•	external_id (string): natural identifier of the conversation.
	•	source_type (string): imessage or sms.
	•	source_provider (string): e.g., apple_messages.
	•	source_account_id (string, nullable).
	•	participants (JSONB): normalized people schema for participants.
	•	is_group (boolean).
	•	first_message_at (timestamp with time zone).
	•	last_message_at (timestamp with time zone).
	•	metadata (JSONB): thread-level metadata (similar partitioning to document metadata but simpler).

For iMessage/SMS:
	•	external_id = chat GUID provided by the Apple messages database.
	•	source_type = imessage or sms depending on how you classify.
	•	One thread has many documents (messages), one document belongs to at most one thread.

Takeaway: thread identity is the chat GUID; all messages in that chat link to the same thread.

5.3 Thread lifecycle and usage

Collectors:
	•	Always include a thread block when they know the conversation (iMessage/SMS).
	•	That block includes:
	•	external_id (chat GUID).
	•	optional initial participants, is_group, and timestamps.

Catalog:
	•	Upserts threads by (source_type, source_provider, source_account_id, external_id).
	•	Maintains first_message_at and last_message_at from documents’ content_timestamp (min/max).
	•	Stores normalized participants based on document people roles such as sender/recipient.

Documents:
	•	Include thread_id (UUID) as a foreign key to threads.
	•	Use threads for:
	•	context windows in intent detection,
	•	social/relationship inference,
	•	thread-based UI and search.

Takeaway: threads are owned by Catalog, populated from collector hints and document timestamps.

⸻

6. Chunks and chunk_documents

6.1 Roles of chunks and chunk_documents
	•	chunks store reusable text fragments and their embeddings.
	•	chunk_documents store the mapping between chunks and documents.

This design supports:
	•	The standard case: one document → many chunks.
	•	Future cases: one chunk representing combined text from multiple documents (e.g., several messages in a thread slice).

Takeaway: chunks are document-agnostic; chunk_documents define how they relate to documents.

6.2 chunks schema

Core fields:
	•	id (UUID).
	•	text (text): chunk text.
	•	text_sha256 (string): hash of chunk text.
	•	embedding_status (enum): pending, complete, failed.
	•	embedding_vector (vector type or external pointer depending on the vector store integration).
	•	source_ref (JSONB, optional): positional metadata relative to a logical text stream.

source_ref (for single-document chunks):

"source_ref": {
  "type": "text_span",
  "start_char": 1024,
  "end_char": 2047
}

For multi-document chunks, source_ref is either null or a more complex structure you can define later.

The ordinal column is removed from chunks.

Takeaway: chunks do not store document identity; they only know about their own text and optional span info.

6.3 chunk_documents schema

Core fields:
	•	chunk_id (UUID).
	•	doc_id (UUID).
	•	ordinal (integer): logical order of the chunk within that document.
	•	weight (float): fraction of the chunk’s text that originates from this document.

Semantics:
	•	For 1 document → N chunks:
	•	ordinal = chunk index in the document’s chunk sequence (0..N-1).
	•	weight = 1.0 for all rows.
	•	For multi-document chunks:
	•	ordinal = order of the document in the chunk’s composite source set (0..M-1).
	•	weight = fraction of the chunk’s text derived from this document (e.g., 0.4, 0.6).

Takeaway: chunk_documents is the single canonical mapping between chunks and documents, and the only place where ordering and weights are stored.

6.4 Chunking process

Standard worker flow:
	1.	Worker fetches document doc_id and its text.
	2.	Worker splits text into N chunks.
	3.	For each chunk:
	•	Inserts a row into chunks with:
	•	text, text_sha256, embedding_status = 'pending', source_ref with a span for this document.
	•	Inserts a row into chunk_documents with:
	•	doc_id, chunk_id, ordinal (0..N-1), weight = 1.0.

Multi-document chunking (future):
	•	Worker constructs a synthetic text from multiple documents (e.g., a slice of a thread).
	•	Inserts a new chunks row with the combined text.
	•	Inserts one row in chunk_documents per document contributing text, with appropriate ordinal and weight.

Takeaway: indexing and RAG operate on chunks; mapping back to documents and threads uses chunk_documents and thread_id on documents.

⸻

7. HostAgent and Collector Responsibilities

7.1 HostAgent responsibilities

HostAgent is responsible for:
	•	All OCR, captioning, face detection, entity extraction, and related enrichment on images/files.
	•	Generating attachment entries with ocr, caption, vision, exif.
	•	Producing document content for file-backed documents:
	•	Extracting text from PDFs/images and setting it as text in CollectorDocument.
	•	Optionally appending attachment OCR content to message/email text for mixed documents.

HostAgent does not interact directly with internal services; it only talks to collectors / Haven.app and returns structured results.

Takeaway: all heavy enrichment happens at the edge; Catalog stores the results but does not re-run those pipelines.

7.2 Collector responsibilities

Collectors must:
	•	Compute external_id according to per-source natural key rules.
	•	Set content_timestamp and content_timestamp_type following the collector-specific rules.
	•	Populate metadata according to the partition:
	•	ingested_at set at ingest time (Catalog or Gateway).
	•	timestamps.primary and timestamps.source_specific.
	•	attachments with HostAgent output when applicable.
	•	source with raw source data.
	•	type with normalized semantics and kind.
	•	enrichment with document-level entities/classification as produced by HostAgent or worker pipelines.
	•	extraction with diagnostics.
	•	Provide people with normalized person objects and roles.
	•	Provide thread data for iMessage/SMS documents when available.

Takeaway: collectors are the only components that understand source systems; they produce fully formed documents ready for Catalog.

⸻

8. Overall Takeaways and Next Steps

Takeaways:
	•	Identity: unify on external_id with a clear source tuple.
	•	Timestamps: single canonical field, plus structured metadata.timestamps.
	•	Metadata: strongly partitioned into ingested_at, timestamps, attachments, source, type, enrichment, and extraction.
	•	Files: no files table; all attachment/image-level enrichment lives in metadata.attachments.
	•	Threads: only for iMessage/SMS, representing 2..n person conversations, keyed by chat GUID.
	•	Chunks: document-agnostic text fragments with a single mapping table chunk_documents controlling relationships and ordering.
	•	HostAgent: responsible for all enrichment and text extraction, producing fully enriched documents at the edge.

Concrete next steps:
	1.	Update the data dictionary to match this spec, replacing or removing conflicting definitions.
	2.	Update Pydantic and Swift models for CollectorDocument, DocumentIngestRequest, ThreadPayload, Chunk, and ChunkDocument to align with this schema.
	3.	Adjust Catalog migrations:
	•	Drop files and document_files.
	•	Drop chunks.ordinal if present.
	•	Ensure constraints on (source_type, source_provider, source_account_id, external_id).
	4.	Update collectors and HostAgent to emit metadata and attachments in the shapes defined here.
	5.	Update workers (chunking, embedding, intent) to rely only on this target state.
